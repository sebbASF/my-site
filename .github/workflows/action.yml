name: Build a Pelican Website2

on:
  workflow_dispatch:
    inputs:
      destination:
        description: "Pelican Output branch"
        required: false
        default: 'gha-site'
      output:
        description: "Output directory"
        required: false
        default: 'output'
      image:
        description: "Docker Image"
        required: false
        default: 'ghcr.io/sebbasf/infra-pelican:latest'


permissions:
  contents: write


jobs:
  build-pelican:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          filter: tree:0
          fetch-depth: 0
          show-progress: false
      - name: Identify Committer
        shell: bash
        run: |
          git config --global user.email "users@infra.apache.org"
          git config --global user.name "Build Pelican (action)"
      - name: Pull Docker
        shell: bash
        run: |
          docker pull --quiet ${{ inputs.image }}
      - name: Run Pelican
        shell: bash
        run: |
          docker run --quiet -v /tmp:/out -v $PWD:/site --entrypoint bash ${{ inputs.image }} \
            -c "source /tmp/pelican-asf/LIBCMARKDIR.sh && python3 -m pelican content -o /out/output"
      - name: Checkout site deploy branch
        shell: bash
        run: |
          if git checkout ${{ inputs.destination }}
          then
            git pull origin ${{ inputs.destination }}
          else
            echo "branch ${{ inputs.destination }} is new; create basic site"
            git config --global --add --bool push.autoSetupRemote true
            git checkout --orphan ${{ inputs.destination }} -f
            git rm -rf .
            # TODO: does it make sense to copy the source version of the file?
            # What is actually needed by the site branch?
            # assume we have an asf.yaml file
            git checkout origin/${{ github.ref_name }} -- .asf.yaml
            git add .asf.yaml -f
          fi
      - name: Remove previous
        shell: bash
        run: |
          # Remove all existing output so deletions will be captured
          rm -rf output
          git rm --quiet -r --ignore-unmatch --cached output/*
      - name: Commit change
        shell: bash
        run: |
          cp -rT /tmp/output ${{ inputs.output }}
          git diff # Show changes
          git add ${{ inputs.output }}
          git status
          if git commit -m "Commit build products"
          then
            git push
          else
            echo "No change"
            true # ensure step is successful
          fi
